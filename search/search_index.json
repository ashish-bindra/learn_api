{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API","text":"<p>Aplication programing Interface is a set of rules and protocols that allow one software application to interact with another.</p> <ul> <li>APIs are used to define the methods for communication between software components</li> </ul>"},{"location":"#brusup","title":"Brusup","text":"<p>You send a request to a server, and it send back a response. but APIs can do much more than that. THey can be used to create new APIs, to modify exisitng APIs and to integrate APis with other APIs.Most of the time that you practice is just <code>data picking</code> from APIs or <code>loop</code>through the data. But APIs can do much more than that.At a max level, you went through the basic of sate menagment.</p> <p>Beyond random user and github API</p>"},{"location":"#step-1-http-methods","title":"step 1: http methods","text":"<p>Master the HTTP method. You should know the difference between GET,PUT,POST,PATCh,DELETE and OPTIONS.</p> <ul> <li>You SHould know when to use each method and what each method does.</li> <li>you should also know how to use thrse method in yur code</li> </ul> <p>GO to FreeAPi Kiten sink and learn to handel all http methods.Try them with different tools  like fetch, postman,axios,etc.</p>"},{"location":"#step2-status-code-and-request-handers","title":"step2: Status code and request handers","text":"<ul> <li>You should know what status codes are and what they mean.</li> <li>you should know to handel different status codes un your code.</li> <li>You should also know how to request headers.</li> <li>you should also know what headers are and what they do. -Know how to set headers in your code.</li> <li>learn things like</li> <li>request header</li> <li>request ip</li> <li>request user agent</li> <li>path variable</li> <li>query parameters</li> </ul>"},{"location":"#step-3-response-handling","title":"Step 3: Response handling","text":"<p>You should know how to handle respinses.</p> <ul> <li>do you how to handle different types of responses?</li> <li>You should know how to handle JSON,XML and other types of responses.</li> <li>You should know how to handle different types of error. you should know how to handle diferent types of responses un your code like</li> </ul> <ul> <li>responses headers</li> <li>response caching</li> <li>response compression (gzip, brotli, etc)</li> <li>response cookies</li> <li>redirect handling</li> <li>Handling Images: Manage image responses in various formats (JPEG, PNG, etc.).</li> </ul>"},{"location":"#step-4-authentication","title":"Step 4: Authentication","text":"<p>You should know how to authenticate with APIs. You should know different types of authencation methods.</p> <ul> <li> <p>You should know how to authentication in your code. Learn things like</p> </li> <li> <p>Baic authtication</p> </li> <li>Beare token</li> <li>OAuth</li> <li>JWT</li> <li>API keys</li> <li>cookies</li> <li>session</li> <li>token</li> <li>refresh token</li> </ul> <p>You should need to learn about mobile authentication and Api handling different from web. THis is completely a bous step.</p>"},{"location":"#step-5-api-rate-linmiting-optional","title":"step 5: API Rate Linmiting (Optional)","text":"<p>You should know how to rate limit APIs.</p> <ul> <li>You should know how too handle in ypur code. You should know hw to handle rate limiting in your Api like</li> <li>Rate limiting</li> <li>Throttling</li> <li>Caching</li> <li>Retry</li> <li>Circuit breaker</li> <li>Backoff</li> <li>Timeout</li> <li>Error handling</li> </ul>"},{"location":"#step-6-bonous-learning","title":"step 6: Bonous learning","text":"<p>You are done btnow/</p> <ul> <li>Webhooks</li> <li>websockets</li> <li>GraphQl</li> <li>gRPC</li> <li>Rest</li> <li>SOAP</li> </ul>"},{"location":"#tools-to-handle-apis","title":"Tools to handle APIS","text":"<ul> <li>Axios</li> <li>Fetch</li> <li>Postman</li> <li>React Query</li> </ul>"},{"location":"API/","title":"DRF","text":""},{"location":"API/#django-rest-framework-restfull-api","title":"Django Rest Framework (Restfull api)","text":"<ul> <li>Django application without REST API is like a human being without hands and legs.</li> <li>It is very, very easy technology and small technology.</li> <li>Mandatory technology.</li> <li>Fewer people know this technology</li> </ul> <p>List of apis  types</p> <ol> <li>API</li> <li>Web API/Web Service</li> <li>REST</li> <li>REST API</li> <li>Django Rest Framework</li> </ol>"},{"location":"API/#1-api-application-programming-interface","title":"1. API =&gt; Application Programming Interface","text":"<ul> <li>The main objective of API is two applications can communicate with each other. API    allows external agent to communicate (integrate and exchange information) with our    application</li> <li></li> <li>Mobile phone keyword act as interface</li> <li>GUI(interface)</li> <li>Interoperability: One application can communicate to another application</li> <li> <p>In a Simple way: 'Methods of communication between software components'</p> </li> <li> <p>Note: Interface of communication between the user and application is nothing but API.    The user can be Human user, an android app or desktop application etc.</p> </li> </ul>"},{"location":"API/#2-web-apiweb-service","title":"2. Web API/Web Service","text":"<ul> <li>The interface of communication between the user and application over the web by using    HTTP is nothing but Web API.</li> <li></li> <li>Eg1: By using API, a java application can communicate with a python application.       Bookmyshow application can communicate with Payment gateway application to       complete our booking.</li> <li>Eg2: Authentication with Facebook</li> <li>Every day we are using api in browser, in mobile, jio recharge, YouTube</li> <li>API which is developed to access web application.</li> </ul>"},{"location":"API/#3-rest-representational-state-transfer","title":"3. REST: Representational State Transfer","text":"<ul> <li>Representational State Transfer (REST) is an architectural style.</li> <li>It defines several Rules/guidelines to develop Web APIs/Web Services</li> <li>By using the REST, we can develop web APIs very easily in concise way.</li> <li>Hence, the REST is the most popular Architecture to develop Web Services.</li> <li>The Rest is language independent</li> </ul>"},{"location":"API/#4-restful-api","title":"4. RESTFul API","text":"<ul> <li>The API which is developed by using REST Architecture is nothing but a RESTFul API. i.e.,    interface between the user and application where API implements REST Architecture.</li> <li>Note: REST is basically an architecture whereas RESTFul API is an API that implements    REST</li> </ul> <p>HTTP =&gt; Common language</p> <ul> <li>Through this application communicate</li> </ul> <p>Common Message Formate =&gt; XML/JSON</p>"},{"location":"API/#http-verbs","title":"HTTP Verbs","text":"<p>HTTP Verbs represent the type of operation what we required. Based on requirement we have to use the corresponding HTTP verb.</p> <p>The following are various HTTP Verbs</p> <ol> <li>GET =&gt; To get one/more existing resources</li> <li>POST =&gt; To create a new resource</li> <li>PUT =&gt; To update an existing resource like update all fields of employee</li> <li>PATCH =&gt; To perform partial updation of an existing resource like updating only salary of employee</li> <li>DELETE =&gt; To delete an existing resource.</li> </ol> <p>Note: These are only important HTTP Verbs.</p>"},{"location":"API/#the-following-are-not-that-much-important-verbs","title":"The following are not that much important verbs","text":"<ul> <li>OPTIONS</li> <li>HEAD</li> <li>CONNECT</li> <li>TRACE</li> <li>LOCK</li> <li>MOVE</li> <li>PROFIND etc</li> </ul>"},{"location":"API/#http-verbs-vs-database-crud-operations","title":"HTTP Verbs vs Database CRUD Operations","text":"<ul> <li>C (CREATE) : POST</li> <li>R (RETRIEVE/READ) :  GET</li> <li>U (UPDATE) : PUT/PATCH</li> <li>D (DELETE) : DELETE</li> </ul>"},{"location":"API/#types-of-web-services","title":"Types of Web Services","text":"<p>There are 2 types of web services</p> <ol> <li>SOAP Based WebServices</li> <li>RESTful WebServices</li> </ol>"},{"location":"API/#1-soap-based-web-services","title":"1. SOAP Based Web Services","text":"<ul> <li>SOAP: Simple Object Access Protocol.</li> <li>SOAP is an XML based protocol for accessing web services.</li> <li>To describe SOAP based web services we have to use a special language: WSDL (Web Service Description Language).</li> <li>SOAP based web services are more secured. We can consume by using RPC Method calls. These web services can provide support for multiple protocols like HTTP, SMTP, FTP etc</li> </ul>"},{"location":"API/#limitations","title":"Limitations","text":"<ol> <li>SOAP Based web services will always provide data only in XML format. Parsing of this XML data is very slow, which creates performance problems.</li> <li>Transfter of XML data over network requires more bandwidth.</li> <li>Implementing SOAP Based Web Services is very difficult.</li> </ol> <p>Note: Because of heavy weight, less performance and more bandwidth requirements, SOAP based web services are not commonly used these days.</p>"},{"location":"API/#2-restful-web-services","title":"2. RESTful Web Services","text":"<ul> <li>REST stands for Representational State Transfer. It means that each unique URL is a represention of some object. We can get contents of this object by using HTTP GET, we can modify by using PUT/PATCH and we can delete by using DELETE.</li> <li>We can create by using POST. \uf0b7 Most of the times RESTful web service will provide data in the form of JSON, parsing is not difficult. Hence this type of web services are faster when compared with SOAP based Web Services.</li> <li>Transfer of JSON Data over the network requires less bandwidth.</li> </ul>"},{"location":"API/#limitations_1","title":"Limitations","text":"<ol> <li>It is less secured.</li> <li>It provide support only for the protocols which can provide URI, mostly HTTP.</li> </ol> <p>Note: Because of ligth weight, high performance, less bandwidth requirements, easy development, human understandable message format, this type of web services are most commonly used type of web services.</p>"},{"location":"API/#differences-between-soap-and-rest","title":"Differences between SOAP and REST","text":"SOAP REST 1) XML-based messaging protocol 1) An architectural style, not a protocol 2) Uses WSDL for communication between consumer and provider 2) Uses XML/JSON to send and receive data 3) Invokes services by using RPC method calls 3) Invokes services by simply using a URL path 4) Does not return human-readable results 4) Returns readable results like plain XML or JSON 5) Heavyweight 5) Lightweight 6) Requires more bandwidth 6) Requires less bandwidth 7) Can support multiple protocols like HTTP, SMTP, FTP, etc. 7) Can support only protocols that provide URIs, mostly HTTP 8) Performance is low 8) Performance is high 9) More secure 9) Less secure <p>Note: Most of the Google web services are SOAP Based. Yahoo \uf0e0 RESTful eBay and Amazon using both SOAP and Restful</p>"},{"location":"API/#web-service-provider-vs-webservice-consumer","title":"Web Service Provider vs WebService Consumer","text":"<ul> <li>The application which is providing web services is called Web Service Provider.</li> <li>The application which is consuming web data through web services, is called Web service consumer.</li> </ul> <p>Eg: Bookmyshow app &lt;--&gt; Payment Gateway app To complete our booking, bookmyshow application will communicates with payment gateway application. Hence payment gateway applications acts as webservice provider and bookmyshow application acts as web service consumer.</p> <p>Great question! Let's explore the reasons for choosing <code>requests</code> vs <code>httpx</code> in FastAPI, and why I initially used <code>requests</code> in the example, but also mentioned <code>httpx</code> as a more suitable option for asynchronous calls.</p>"},{"location":"API/#why-use-requests-synchronous","title":"Why Use <code>requests</code> (Synchronous)?","text":"<p><code>requests</code> is a widely-used, easy-to-understand library for making HTTP requests. It's synchronous, meaning the application will wait for the HTTP request to complete before moving on to the next task. It\u2019s a good choice in the following scenarios:</p> <ol> <li> <p>Simplicity and Readability: <code>requests</code> is known for its simplicity and readability, making it easy to use for beginners or those working on smaller projects. The code looks clean and the syntax is intuitive.</p> </li> <li> <p>Blocking Operations: If your FastAPI application doesn't need to handle multiple concurrent tasks (e.g., if it\u2019s low-traffic or doesn\u2019t involve large-scale data fetching), using <code>requests</code> might be perfectly fine. It's simple to implement when you're building an API or application that doesn't need the added complexity of asynchronous behavior.</p> </li> <li> <p>No Need for Concurrency: If you don\u2019t have multiple HTTP requests happening at once, using <code>requests</code> might make your life easier since you don't need to deal with async/await.</p> </li> </ol>"},{"location":"API/#example-use-case-for-requests","title":"Example Use Case for <code>requests</code>","text":"<p>If your FastAPI API is fetching data from another API on a relatively small scale, and you don't mind the application being \"blocked\" while it waits for the response, <code>requests</code> will do the job. It simplifies the development process and is good enough for small, straightforward applications.</p>"},{"location":"API/#why-use-httpx-asynchronous","title":"Why Use <code>httpx</code> (Asynchronous)?","text":"<p><code>httpx</code> is an asynchronous HTTP client designed for high-performance applications. FastAPI is built with async and await functionality in mind, and using <code>httpx</code> aligns well with FastAPI's capabilities. Here are some key reasons why <code>httpx</code> is the preferred choice in an asynchronous environment:</p> <ol> <li>Asynchronous Requests:</li> <li><code>httpx</code> is designed for asynchronous calls, meaning it does not block your application while waiting for a response. This allows your FastAPI application to handle multiple HTTP requests concurrently, leading to better performance in high-traffic scenarios.</li> <li> <p>With <code>httpx</code>, you can handle many requests at once without waiting for each one to finish before starting the next. This is ideal for APIs that need to fetch data from multiple sources simultaneously or those with high concurrent users.</p> </li> <li> <p>Non-Blocking:</p> </li> <li>FastAPI works well with asynchronous frameworks. If you're making HTTP requests in an endpoint and need to perform additional tasks (like querying databases, fetching multiple APIs, or processing data), using <code>httpx</code> ensures that your server doesn't block and waits for each task to finish sequentially.</li> <li> <p><code>httpx</code> leverages the async I/O model in Python, which can handle thousands of requests concurrently without waiting for each one to finish.</p> </li> <li> <p>Better Scalability:</p> </li> <li> <p>For APIs with high concurrency (like real-time data fetching from external services or high-frequency updates), using <code>httpx</code> can significantly improve performance, as FastAPI is designed for async operation. Without async I/O, a synchronous request with <code>requests</code> would block the server during the request/response cycle, making it less efficient under load.</p> </li> <li> <p>HTTP/2 Support:</p> </li> <li> <p><code>httpx</code> also supports HTTP/2, which can improve performance for some applications by enabling multiplexing (multiple requests on a single connection).</p> </li> <li> <p>More Control:</p> </li> <li><code>httpx</code> provides advanced features like connection pooling, handling streaming responses, and customizable timeouts, which can give you more control over how your requests are managed.</li> </ol>"},{"location":"API/#example-use-case-for-httpx","title":"Example Use Case for <code>httpx</code>","text":"<p>If your FastAPI application is interacting with multiple APIs, handling high traffic, or needs to fetch data concurrently from many sources, <code>httpx</code> is the better choice as it won't block the server while waiting for responses and will handle multiple requests efficiently.</p>"},{"location":"API/#when-to-use-requests-vs-httpx-in-fastapi","title":"When to Use <code>requests</code> vs <code>httpx</code> in FastAPI","text":"Feature <code>requests</code> (Synchronous) <code>httpx</code> (Asynchronous) Concurrency Handling Blocks the event loop, handles one request at a time Non-blocking, handles multiple requests concurrently Performance with High Traffic Slower, as each request blocks the thread Faster for high concurrency, as requests are non-blocking Ease of Use Simpler, easy to understand and use Requires knowledge of async programming, more complex Ideal Use Case Small apps with low traffic, or simple applications High-concurrency apps, APIs fetching from multiple sources Integration with FastAPI Works fine for small projects Best for projects designed for high concurrency and scalability"},{"location":"API/#example","title":"Example","text":""},{"location":"API/#using-requests-simple-blocking","title":"Using <code>requests</code> (Simple, Blocking)","text":"<pre><code>import requests\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/fetch-todo/{todo_id}\")\nasync def fetch_todo(todo_id: int):\n    url = f\"https://jsonplaceholder.typicode.com/todos/{todo_id}\"\n    response = requests.get(url)\n    return response.json()\n</code></pre> <p>In this example, FastAPI will wait for <code>requests.get(url)</code> to complete before processing the next request. If multiple users hit the endpoint simultaneously, each request will wait for the previous one to finish.</p>"},{"location":"API/#using-httpx-async-non-blocking","title":"Using <code>httpx</code> (Async, Non-Blocking)","text":"<pre><code>import httpx\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/fetch-todo/{todo_id}\")\nasync def fetch_todo(todo_id: int):\n    url = f\"https://jsonplaceholder.typicode.com/todos/{todo_id}\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n    return response.json()\n</code></pre> <p>With <code>httpx</code>, FastAPI can handle multiple requests concurrently without waiting for the response of each individual one. This is especially useful for high-traffic APIs or applications that need to perform multiple I/O-bound operations.</p>"},{"location":"API/#conclusion","title":"Conclusion","text":"<ul> <li><code>requests</code> is simple and easy to use, and works fine for small applications or scenarios where concurrency isn\u2019t a concern.</li> <li><code>httpx</code> is a better choice for asynchronous applications that need to handle multiple requests concurrently and scale efficiently. FastAPI is designed to work with asynchronous frameworks, so <code>httpx</code> integrates better with FastAPI for optimal performance.</li> </ul> <p>If your FastAPI app is expected to handle a lot of traffic or needs to fetch data from multiple sources concurrently, <code>httpx</code> is the better choice. However, for smaller applications, <code>requests</code> might be sufficient, especially when simplicity and quick development are more important.</p> <p>Let me know if you need further clarification!</p>"},{"location":"about/","title":"imp link","text":""},{"location":"about/#free-api-website","title":"Free API website","text":"<ol> <li>jsonplaceholder</li> <li>publicapis</li> <li>ipinfo</li> <li>dog.ceo</li> <li>thecatapi</li> <li>nasa</li> <li>https://v2.jokeapi.dev/</li> <li>https://github.com/public-apis/public-apis</li> <li>https://www.freepublicapis.com/</li> <li>https://api.freeapi.app/api/v1/public/quotes/quote/random</li> <li>https://free-apis.github.io/#/</li> <li>https://http.cat/?ref=apilist.fun</li> <li>https://reqres.in/</li> <li>https://apipheny.io/free-api/</li> <li>https://freeapi.hashnode.space/</li> </ol> <p>best freeAPI</p>"},{"location":"apiview/","title":"ViewSet","text":"<p>Viewset are different and apiview methods are different Viewset is alternative to APIView</p> <p>APIView =&gt; get(),put(),patch(),post(),delete()</p>"},{"location":"apiview/#viewset_1","title":"ViewSet","text":"<ul> <li>list() =&gt; To get all resources/records</li> <li>retrieve() =&gt; To get a specific resource</li> <li>create() =&gt; To create a new resource</li> <li>update() =&gt; To perform full updation</li> <li>partial_update() =&gt; To perform partial update</li> <li>destroy() =&gt; To delete a resource</li> </ul> <p>Only method names are different, but the remaining functionality is the same</p> <ul> <li>get() = list(),retrieve()</li> <li>post() =&gt; create()</li> <li>put() =&gt; update()</li> <li>patch() =&gt; partial_update()</li> <li>delete() =&gt; destroy()</li> </ul> <p>if we want to create a fast api, go for viewset-recommended apiview everything we have to write</p>"},{"location":"apiview/#q1-when-viewset-is-a-best-choice","title":"Q1 When ViewSet is a Best Choice","text":"<ol> <li>If we want to develop a simple CRUD interface for our database</li> <li>If we want to develop API very quickly</li> <li>If we are performing standard operation</li> <li>If we are not performing any complex operation</li> </ol> <p>APIView we are response to define URL patteren(URL match)</p> <p>In viewset: Routers will map views to urls automatically</p>"},{"location":"apiview/#q-how-to-define-a-router","title":"Q How to define a router?","text":"<p>DFR provides a special class =&gt; DefaultRouter: automatically define router</p>"},{"location":"apiview/#q-how-to-create-default-router","title":"Q How to create Default router","text":"<p>base_name =&gt; basename they change the variable name</p> <p>usage of multiple view is not required one viewset is enough they need primary key: retrieve(), update(),partial_update(),destroy()</p> <p>viewset always talk about database CRUD operation only for normal view method better to go apiview</p> <p>views.py =&gt; Business logic</p>"},{"location":"apiview/#demo-application-for-apiview-with-models","title":"Demo application for APIView with models","text":""},{"location":"apiview/#how-to-use-apiviews-to-perform-crud-operations","title":"How to use APIViews to perform CRUD Operations","text":"<p>APIView ListAPIView =&gt;List out all records CreateAPIView =&gt; Create a new record</p>"},{"location":"apiview/#retrieve-operation","title":"Retrieve Operation","text":"<p>To get a particular record(detail operation)</p> <p>RetrieveAPIView</p>"},{"location":"apiview/#apiview","title":"APIView","text":"<ol> <li>ListAPIView</li> <li>CreateAPIView</li> <li>RetrieveAPIView</li> <li>UpdateAPIView</li> <li>DestroyAPIView</li> <li>ListCreateAPIView</li> <li>RetrieveUpdateAPIView</li> <li>RetrieveDestroyAPIView</li> <li>RetrieveUpdateDestroyAPIView</li> </ol>"},{"location":"apiview/#implement-both-list-and-create-simultaneously","title":"Implement both list and Create simultaneously","text":"<p>ListCreateAPIView</p>"},{"location":"apiview/#implementboth-retrieve-and-update-operation","title":"ImplementBoth Retrieve and Update Operation","text":"<p>RetrieveUpdateApiView</p>"},{"location":"apiview/#implement-both-retrieve-and-delete-operation","title":"Implement Both Retrieve and Delete Operation","text":"<p>RetrieveDestroyAPIView</p> <p>Dont go for apiView go for viewset</p>"},{"location":"auth/","title":"Authentication and Authorization","text":""},{"location":"auth/#authentication","title":"Authentication","text":"<p>The process of validating user is called authentication.</p> <ul> <li>username and pwd combination</li> <li>token</li> </ul> <p>Drf Provides servers inbuilt authentication mechanisms</p> <ol> <li>Basic Authentication</li> <li>session authentication</li> <li>token authentication</li> <li>JWT (Json Web Token) Authentication etc</li> </ol>"},{"location":"auth/#authorization","title":"Authorization","text":"<p>Valid customer of ICIC Bank</p> <ul> <li>How much balance amitaab buschan has?</li> <li>You have no authorization to access that information, access person to access that resource</li> </ul> <p>The process of validating access permissions of user</p> <ul> <li>After authentication, We have to perform authorization</li> </ul> <p>DRF provide permission-classed</p> <ul> <li>AllowAny</li> <li>IsAuthenticated</li> <li>IsAdminUser</li> <li>IsAuthenticatedOrReadOnly</li> <li>DjangoModelPermissions</li> <li>DjangoModelPermissionsOrAnonReadOnly</li> </ul> <p>READ Operation: GET, OPTIONS, HEAD =&gt; SAFE METHOD Write Operations: POST, PUT, PATCH =&gt;</p>"},{"location":"auth/#token-authentication","title":"Token Authentication","text":"<ul> <li>Authentication can be performed by some token</li> </ul> <p>native desktop clients,mobile clients</p> <ul> <li>Token must be generated for every user</li> <li>Token must be validated for every user</li> </ul> <p>authtoken application =&gt; inbuilt application provided by DRF</p> <ol> <li>include authtoken application in our installed application list</li> <li>Token table</li> <li>migrate commanded needed</li> <li>url pattern of authtoken</li> </ol>"},{"location":"auth/#http","title":"http","text":"<ol> <li>authtoken application can validate this username and pwd</li> <li>authtoken application will check whether the Token is already generated for this user or not</li> <li>If a token is already generated for this user, then the existing token will be returned.</li> <li>If token is not already genrated, then a new token willl be created and stored in tokens table and send token as the response</li> </ol> <p>How to enable Authntication and Authorization(permission) for our view class/vendor</p> <ul> <li>Globally inside setting.py file</li> <li>locally</li> </ul>"},{"location":"help/","title":"Help","text":"<p>Here through the ear and listening through the mind.</p>"},{"location":"mixing/","title":"Mixins","text":""},{"location":"mixing/#reusable-components","title":"Reusable components","text":"<ul> <li>Normal classes meant for code reusability</li> <li>direct child class of an object (mens no other dependency)</li> <li>contain only method (no variable)</li> </ul>"},{"location":"mixing/#viewset","title":"viewset","text":"<ul> <li>very easy and fast way to develop api</li> <li>not require to configer urls</li> <li>most of the business logic perform internally automatically</li> </ul> <p>it is the model-based view set</p>"},{"location":"project/","title":"Projects","text":""},{"location":"project/#drf-projects","title":"DRF projects","text":""},{"location":"project/#installation","title":"Installation","text":"<ul> <li> <p>Install using pip, including any optional packages you want...</p> </li> <li> <p><code>pip install djangorestframework</code></p> </li> <li><code>pip install markdown</code>      # Markdown support for the browsable API.</li> <li><code>pip install django-filter</code>  # Filtering support</li> </ul>"},{"location":"project/#step-1","title":"Step - 1","text":"<pre><code> django-admin startproject project_name\n</code></pre>"},{"location":"project/#step-2","title":"Step - 2","text":"<pre><code>cd project_name\npy manage.py startapp appname\n</code></pre>"},{"location":"project/#step-3","title":"Step - 3","text":"<p>Add <code>rest_framework</code> to your INSTALLED_APPS setting.</p> <pre><code>INSTALLED_APPS = [\n    ...\n    'rest_framework',\n]\n</code></pre> <p>add app name also</p>"},{"location":"project/#step-4","title":"Step - 4","text":"<ul> <li>Go to appname/view.py</li> <li>Response() =&gt; convert python dict to json data</li> <li>Response() provided by drf</li> </ul> <pre><code>from rest_framework.views import APIView\nclass AssignmentAPIVIEW(APIView):\n  def get(self, request, *args, **kwargs):\n      return Response({\"msg\": \"Happy Ashish\"})\n</code></pre>"},{"location":"project/#step-5","title":"Step - 5","text":"<ul> <li>goto <code>urls.py</code></li> </ul> <pre><code>from appname import views\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('api/',views.TestAPIVIEW.as_view())\n]\n</code></pre>"},{"location":"project/#step-6","title":"Step - 6","text":"<pre><code>py manage.py makemigrations\npy manage.py migrate\n</code></pre>"},{"location":"project/#step-7","title":"Step -7","text":"<p>Browsable api</p> <pre><code>py manage.py runserver\n</code></pre>"},{"location":"project/#post-request","title":"POST Request","text":"<ul> <li>Partner application will send some <code>json_data</code></li> <li>some conversion must be required to convert some data in python dict for serializer must be required</li> <li>if model is not there and the normal daata is there then dont go for model_serializer go for normal serializer</li> <li></li> <li></li> <li></li> <li></li> <li>if we don't write anything, if we send empty data</li> <li></li> <li>internal csrf certification is send by browsable api</li> </ul>"},{"location":"python/","title":"API code","text":""}]}